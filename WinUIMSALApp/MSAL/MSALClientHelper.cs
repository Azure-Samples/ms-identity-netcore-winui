using Microsoft.Extensions.Configuration;
using Microsoft.Identity.Client;
using Microsoft.Identity.Client.Broker;
using Microsoft.Identity.Client.Extensions.Msal;
using Microsoft.IdentityModel.Abstractions;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;
using static System.Formats.Asn1.AsnWriter;

namespace WinUIMSALApp.MSAL
{
    /// <summary>
    /// Contains methods that initialize and use the MSAL SDK
    /// </summary>
    /// <autogeneratedoc />
    public class MSALClientHelper
    {
        /// <summary>
        /// As for the Tenant, you can use a name as obtained from the azure portal, e.g. kko365.onmicrosoft.com"
        /// </summary>

        public readonly AzureADConfig AzureADConfig;

        /// <summary>
        /// Gets the authentication result (if available) from MSAL's various operations.
        /// </summary>
        /// <value>
        /// The authentication result.
        /// </value>

        public AuthenticationResult AuthResult { get; private set; }

        /// <summary>
        /// Gets the current user account (if available) from the MSAL token caching mechanism.
        /// </summary>
        /// <value>
        /// The current user account.
        /// </value>

        public IAccount CurrentUserAccount { get; private set; }

        /// <summary>
        /// Gets a value indicating whether this instance of PublicClientApp was initialized with a broker .
        /// </summary>
        /// <value>
        ///   <c>true</c> if this instance is broker initialized; otherwise, <c>false</c>.
        /// </value>

        public bool IsBrokerInitialized { get; private set; }

        /// <summary>
        /// Gets the MSAL public client application instance.
        /// </summary>
        /// <value>
        /// The public client application.
        /// </value>

        public IPublicClientApplication PublicClientApplication { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="MSALClientHelper"/> class.
        /// </summary>

        public MSALClientHelper()
        {
            // Using appsettings.json as our configuration settings and utilizing IOptions pattern - https://learn.microsoft.com/dotnet/core/extensions/options
            var configuration = new ConfigurationBuilder().AddJsonFile("appsettings.json").Build();
            AzureADConfig = configuration.GetSection("AzureAD").Get<AzureADConfig>();
        }

        /// <summary>
        /// Initializes the public client application of MSAL.NET with the required information to correctly authenticate the user.
        /// </summary>
        /// <returns></returns>

        public async Task<IAccount> InitializePublicClientAppAsync()
        {
            // Initialize the MSAL library by building a public client application
            this.PublicClientApplication = PublicClientApplicationBuilder.Create(AzureADConfig.ClientId)
                .WithAuthority(string.Format(AzureADConfig.Authority, AzureADConfig.TenantId))
                .WithRedirectUri(string.Format(AzureADConfig.RedirectURL, AzureADConfig.ClientId))  // Skipping this will make MSAL fall back to older Uri: urn:ietf:wg:oauth:2.0:oob
                .WithLogging(new IdentityLogger(EventLogLevel.Warning), enablePiiLogging: false)    // This is the currently recommended way to log MSAL message. For more info refer to https://github.com/AzureAD/microsoft-authentication-library-for-dotnet/wiki/logging. Set Identity Logging level to Warning which is a middle ground
                .WithClientCapabilities(new string[] { "cp1" })                                     // declare this client app capable of receiving CAE events- https://aka.ms/clientcae
                .Build();

            IEnumerable<IAccount> accounts = await AttachTokenCache();
            CurrentUserAccount = accounts.FirstOrDefault();
            return this.CurrentUserAccount;
        }

        /// <summary>
        /// Initializes the public client application of MSAL.NET with the required information to correctly authenticate the user.
        /// </summary>
        /// <returns></returns>

        public async Task<IAccount> InitializePublicClientAppForWAMBrokerAsync()
        {
            // Initialize the MSAL library by building a public client application
            this.PublicClientApplication = PublicClientApplicationBuilder.Create(AzureADConfig.ClientId)
                .WithAuthority(string.Format(AzureADConfig.Authority, AzureADConfig.TenantId))
                .WithRedirectUri(string.Format(AzureADConfig.RedirectURL, AzureADConfig.ClientId))              // Skipping this will make MSAL fall back to older Uri: urn:ietf:wg:oauth:2.0:oob
                .WithBrokerPreview(true)
                .WithParentActivityOrWindow(() => { return WinRT.Interop.WindowNative.GetWindowHandle(this); }) // Specify Window handle - (required for WAM).
                .WithLogging(new IdentityLogger(EventLogLevel.Warning), enablePiiLogging: false)                // This is the currently recommended way to log MSAL message. For more info refer to https://github.com/AzureAD/microsoft-authentication-library-for-dotnet/wiki/logging. Set Identity Logging level to Warning which is a middle ground
                .WithClientCapabilities(new string[] { "cp1" })                                                 // declare this client app capable of receiving CAE events- https://aka.ms/clientcae
                .Build();

            this.IsBrokerInitialized = true;

            IEnumerable<IAccount> accounts = await AttachTokenCache();
            CurrentUserAccount = accounts.FirstOrDefault();
            return this.CurrentUserAccount;
        }

        /// <summary>
        /// Attaches the token cache to the Public Client app.
        /// </summary>
        /// <returns></returns>

        public async Task<IEnumerable<IAccount>> AttachTokenCache()
        {
            // Cache configuration and hook-up to public application. Refer to https://github.com/AzureAD/microsoft-authentication-extensions-for-dotnet/wiki/Cross-platform-Token-Cache#configuring-the-token-cache
            var storageProperties = new StorageCreationPropertiesBuilder(AzureADConfig.CacheFileName, AzureADConfig.CacheDir).Build();
            var msalcachehelper = await MsalCacheHelper.CreateAsync(storageProperties);
            msalcachehelper.RegisterCache(PublicClientApplication.UserTokenCache);

            var accounts = await PublicClientApplication.GetAccountsAsync();
            return accounts;
        }

        /// <summary>
        /// Signs in the user and obtains an Access token for a provided set of scopes
        /// </summary>
        /// <param name="scopes"></param>
        /// <returns> Access Token</returns>
        public async Task<string> SignInUserAndAcquireAccessToken(string[] scopes)
        {
            this.CurrentUserAccount ??= (await this.PublicClientApplication.GetAccountsAsync()).FirstOrDefault();

            try
            {
                this.AuthResult = await this.PublicClientApplication.AcquireTokenSilent(scopes, this.CurrentUserAccount)
                    .ExecuteAsync();
            }
            catch (MsalUiRequiredException ex)
            {
                // A MsalUiRequiredException happened on AcquireTokenSilentAsync. This indicates you need to call AcquireTokenAsync to acquire a token
                Debug.WriteLine($"MsalUiRequiredException: {ex.Message}");

                // Must be called from UI thread
                this.AuthResult = await this.PublicClientApplication.AcquireTokenInteractive(scopes)
                                                  //.WithClaims("{\"id_token\":{\"deviceid\":{\"essential\":true}}}") // you can use WithClaims() to request additional claims, like in this case a compliant device can provide the deviceid claim in token.
                                                  .ExecuteAsync();
            }
            catch (MsalException msalEx)
            {
                Debug.WriteLine($"Error Acquiring Token:{Environment.NewLine}{msalEx}");
            }

            return this.AuthResult.AccessToken;
        }

        public async void SignOutUser(IAccount user)
        {
            await this.PublicClientApplication.RemoveAsync(user).ConfigureAwait(false);
        }

        public async Task<IAccount> GetFirstSignedInAccount()
        {
            IEnumerable<IAccount> accounts = await this.PublicClientApplication.GetAccountsAsync().ConfigureAwait(false);
            return accounts.FirstOrDefault();
        }

        /// <summary>
        /// Signs the in user and acquire access token for a provided set of scopes.
        /// </summary>
        /// <param name="scopes">The scopes.</param>
        /// <param name="extraclaims">The extra claims, usually from CAE. We basically handle CAE by sending the user back to Azure AD for additional processing and requesting a new access token for Graph</param>
        /// <returns></returns>

        public async Task<String> SignInUserAndAcquireAccessToken(string[] scopes, string extraclaims)
        {
            this.CurrentUserAccount ??= (await this.PublicClientApplication.GetAccountsAsync()).FirstOrDefault();

            try
            {
                // Send the user to Azure for re-authentication
                this.AuthResult = await PublicClientApplication.AcquireTokenInteractive(scopes).WithAccount(this.CurrentUserAccount)
                                .WithClaims(extraclaims).ExecuteAsync();
            }
            catch (MsalException msalEx)
            {
                Debug.WriteLine($"Error Acquiring Token:{Environment.NewLine}{msalEx}");
            }

            return this.AuthResult.AccessToken;
        }

        private async Task<AuthenticationResult> LoginSilentAndInteractiveAsync(string[] scopes)
        {
            var existingAccount = await FetchAnExistingAccountFromCache().ConfigureAwait(false);

            try
            {
                // 1. Try to sign-in the previously signed-in account
                if (existingAccount != null)
                {
                    Console.WriteLine("Found account in the cache - trying to use it");

                    return await this.PublicClientApplication.AcquireTokenSilent(scopes, existingAccount)
                            .ExecuteAsync();
                }
                // 2. If it does not exist, try to sign in with the OS account. Only Windows broker supports this
                else
                {
                    if (this.IsBrokerInitialized)
                    {
                        Console.WriteLine("No accounts found in the cache. Trying Window's default account.");

                        return await this.PublicClientApplication.AcquireTokenSilent(
                            scopes,
                            Microsoft.Identity.Client.PublicClientApplication.OperatingSystemAccount)
                                .ExecuteAsync();
                    }
                }
            }
            catch (MsalUiRequiredException ex)
            {
                Console.WriteLine("Could not acquire a token silently from cache or broker... " + ex);
            }

            // 3. If all else fails, use interactive auth
            return await LoginInteractiveAsync(scopes, existingAccount).ConfigureAwait(false);
        }

        private async Task<AuthenticationResult> LoginInteractiveAsync(string[] scopes, IAccount existingAccount = null)
        {
            // If the operating system has UI
            if (this.PublicClientApplication.IsUserInteractive())
            {
                return await this.PublicClientApplication.AcquireTokenInteractive(scopes)
                    .WithLoginHint(existingAccount?.Username ?? String.Empty)
                    // .WithParentActivityOrWindow(WindowsHelper.GetConsoleOrTerminalWindow()) // TODO: fix it
                    .ExecuteAsync()
                    .ConfigureAwait(false);
            }

            // If the operating system does not have UI (e.g. SSH into Linux), you can fallback to device code, however this
            // flow will not satisfy the "device is managed" CA policy.
            return await this.PublicClientApplication.AcquireTokenWithDeviceCode(scopes, (dcr) =>
            {
                Console.WriteLine(dcr.Message);
                return Task.CompletedTask;
            }).ExecuteAsync().ConfigureAwait(false);
        }

        private async Task<IAccount> FetchAnExistingAccountFromCache()
        {
            // get accounts from cache
            IEnumerable<IAccount> accounts = await this.PublicClientApplication.GetAccountsAsync().ConfigureAwait(false);

            // Error corner case: we should always have 0 or 1 accounts, not expecting > 1
            // This is just an example of how to resolve this ambiguity, which can arise if more apps share a token cache.
            // Note that some apps prefer to use a random account from the cache.
            if (accounts.Count() > 1)
            {
                foreach (var acc in accounts)
                {
                    await this.PublicClientApplication.RemoveAsync(acc);
                }
                return null;
            }

            return accounts.SingleOrDefault();
        }
    }
}