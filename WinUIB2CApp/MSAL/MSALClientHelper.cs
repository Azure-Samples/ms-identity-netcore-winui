using Microsoft.Identity.Client;
using Microsoft.Identity.Client.Extensions.Msal;
using Microsoft.IdentityModel.Abstractions;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;

namespace WinUIMSALAppB2C.MSAL
{
    /// <summary>
    /// Contains methods that initialize and use the MSAL SDK
    /// </summary>
    /// <autogeneratedoc />
    public class MSALClientHelper
    {
        private IntPtr _windowHandle;

        /// <summary>
        /// As for the Tenant, you can use a name as obtained from the azure portal, e.g. kko365.onmicrosoft.com"
        /// </summary>
        private readonly AzureADB2CConfig _azureADB2CConfig;

        /// <summary>
        /// The public client application used by the app
        /// </summary>
        private IPublicClientApplication _publicClientApplication;
        public IPublicClientApplication PublicClientApplication {
            get
            {
                if (_publicClientApplication is null)
                {
                    _publicClientApplication = PublicClientApplicationBuilder.Build();
                }

                return _publicClientApplication;
            }
        }

        private PublicClientApplicationBuilder _publicClientApplicationBuilder;
        private PublicClientApplicationBuilder PublicClientApplicationBuilder
        {
            get
            {
                if (_publicClientApplicationBuilder is null)
                {
                    _publicClientApplicationBuilder = PublicClientApplicationBuilder.Create(_azureADB2CConfig.ClientId)
                        .WithB2CAuthority($"{_azureADB2CConfig.Instance}/tfp/{_azureADB2CConfig.Domain}/{_azureADB2CConfig.SignUpSignInPolicyid}")
                        .WithRedirectUri($"msal{_azureADB2CConfig.ClientId}://auth")
                        .WithLogging(new IdentityLogger(EventLogLevel.Informational), enablePiiLogging: false);    // This is the currently recommended way to log MSAL message. For more info refer to https://github.com/AzureAD/microsoft-authentication-library-for-dotnet/wiki/logging. Set Identity Logging level to Warning which is a middle ground
                }

                return _publicClientApplicationBuilder;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MSALClientHelper"/> class.
        /// </summary>
        public MSALClientHelper(AzureADB2CConfig azureADB2CConfig, IntPtr winHandle)
        {
            _azureADB2CConfig = azureADB2CConfig;
            _windowHandle = winHandle;
        }

        /// <summary>
        /// Initializes the public client application of MSAL.NET with the required information to correctly authenticate the user account.
        /// </summary>
        /// <returns>An IAccount of an already signed-in user account (if available)</returns>
        public async Task InitializeB2CTokenCacheAsync()
        {
            // Cache configuration and hook-up to public application. Refer to https://github.com/AzureAD/microsoft-authentication-extensions-for-dotnet/wiki/Cross-platform-Token-Cache#configuring-the-token-cache
            var storageProperties = new StorageCreationPropertiesBuilder(
                _azureADB2CConfig.CacheFileName, _azureADB2CConfig.CacheDir).Build();

            var msalcachehelper = await MsalCacheHelper.CreateAsync(storageProperties);

            msalcachehelper.RegisterCache(PublicClientApplication.UserTokenCache);
        }

        /// <summary>
        /// Acquires an access token for a provided set of scopes for an account
        /// </summary>
        /// <param name="scopes"></param>
        /// <returns> Access Token</returns>
        public async Task<string> AcquireAccessTokenForUserAccountAsync(string[] scopes)
        {
            var existingAccount = await FetchAuthenticatedAccountFromCacheAsync().ConfigureAwait(false);

            try
            {
                var authResult = await this.PublicClientApplication.AcquireTokenSilent(scopes, existingAccount)
                    .ExecuteAsync()
                    .ConfigureAwait(false);

                return authResult.AccessToken;
            }
            catch (MsalUiRequiredException ex)
            {
                // A MsalUiRequiredException happened on AcquireTokenSilentAsync. This indicates you need to call AcquireTokenInteractive to acquire a token interactively
                Debug.WriteLine($"MsalUiRequiredException: {ex.Message}");

                // Must be called from UI thread
                var authResult = await this.PublicClientApplication.AcquireTokenInteractive(scopes)
                    .WithLoginHint(existingAccount?.Username ?? String.Empty)
                    .ExecuteAsync()
                    .ConfigureAwait(false);

                return authResult.AccessToken;
            }
            catch (MsalException msalEx)
            {
                Debug.WriteLine($"Error Acquiring Token:{Environment.NewLine}{msalEx}");

                throw msalEx;
            }
        }

        /// <summary>
        /// Removes the first signed-in user's account record from token cache
        /// </summary>
        public async Task SignOutUserAccountAsync()
        {
            var existingUserAccount = await FetchAuthenticatedAccountFromCacheAsync().ConfigureAwait(false);
            await this.PublicClientApplication.RemoveAsync(existingUserAccount).ConfigureAwait(false);
        }

        /// <summary>
        /// Fetches the signed in user account from MSAL's token cache (if available).
        /// </summary>
        /// <returns></returns>
        public async Task<IAccount> FetchAuthenticatedAccountFromCacheAsync()
        {
            // get accounts from cache
            IEnumerable<IAccount> accounts = await this.PublicClientApplication.GetAccountsAsync().ConfigureAwait(false);

            // Error corner case: we should always have 0 or 1 accounts, not expecting > 1
            // This is just an example of how to resolve this ambiguity, which can arise if more apps share a token cache.
            // Note that some apps prefer to use a random account from the cache.
            if (accounts.Count() > 1)
            {
                foreach (var acc in accounts)
                {
                    await this.PublicClientApplication.RemoveAsync(acc);
                }

                return null;
            }

            return accounts.SingleOrDefault();
        }
    }
}